{"id":"B922X8","version":19,"snippetIdentifier":"B922X8-19","jsonPayload":"{\"code\":\"/**\\r\\n * Physics WebXR playground.\\r\\n * Objects can be picked using the squeeze button of the left controller (if available) and can be thrown.\\r\\n * The left trigger resets the scene, right trigger shoots a bullet straight.\\r\\n * \\r\\n * Both hands and the headset have impostors, so you can touch the objects, move them, headbutt them.\\r\\n * \\r\\n * Use the boxing area in the center to understand how the hand and head impostors work.\\r\\n * \\r\\n * Created by Raanan Weber (@RaananW)\\r\\n */\\r\\n\\r\\nvar createScene = async function () {\\r\\n\\r\\n    // This creates a basic Babylon Scene object (non-mesh)\\r\\n    var scene = new BABYLON.Scene(engine);\\r\\n    const gravityVector = new BABYLON.Vector3(0, -9.8, 0);\\r\\n    const physicsPlugin = new BABYLON.CannonJSPlugin();\\r\\n    scene.enablePhysics(gravityVector, physicsPlugin);\\r\\n\\r\\n    var camera = new BABYLON.FreeCamera(\\\"camera1\\\", new BABYLON.Vector3(0, 10, 80), scene);\\r\\n    camera.setTarget(new BABYLON.Vector3(0, 10, 400));\\r\\n    camera.attachControl(canvas, true);\\r\\n\\r\\n    var light = new BABYLON.HemisphericLight(\\\"light\\\", new BABYLON.Vector3(0, 1, 0), scene);\\r\\n    light.intensity = 0.7;\\r\\n\\r\\n    var environment = scene.createDefaultEnvironment({ createGround: false, skyboxSize: 1000 });\\r\\n    environment.setMainColor(BABYLON.Color3.FromHexString(\\\"#74b9ff\\\"));\\r\\n\\r\\n    var ground = BABYLON.MeshBuilder.CreateGround(\\\"ground\\\", { width: 1000, height: 1000 }, scene);\\r\\n    ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.8, restitution: 0.5, disableBidirectionalTransformation: true }, scene);\\r\\n    ground.checkCollisions = true;\\r\\n    ground.material = new BABYLON.GridMaterial(\\\"mat\\\", scene);\\r\\n\\r\\n    // towers\\r\\n    var towerMeshes = [];\\r\\n    for (var x = 0; x < 7; x++) {\\r\\n        for (var z = 0; z < 7; z++) {\\r\\n            var box1 = BABYLON.MeshBuilder.CreateBox(\\\"towerBox\\\",\\r\\n                { width: 2, height: 2, depth: 2 }, scene);\\r\\n            box1.position.x = (x - 4) * 6;\\r\\n            box1.position.y = 2 + z * 2;\\r\\n            box1.position.z = 100;\\r\\n            box1.physicsImpostor = new BABYLON.PhysicsImpostor(box1,\\r\\n                BABYLON.PhysicsImpostor.BoxImpostor,\\r\\n                { mass: 1, friction: 0.5, restitution: 0 }, scene);\\r\\n            towerMeshes.push(box1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // spheres\\r\\n    var materialAmiga = new BABYLON.StandardMaterial(\\\"amiga\\\", scene);\\r\\n    materialAmiga.diffuseTexture = new BABYLON.Texture(\\\"./playground.babylonjs.com/textures/amiga.jpg\\\", scene);\\r\\n    materialAmiga.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);\\r\\n    materialAmiga.diffuseTexture.uScale = 5;\\r\\n    materialAmiga.diffuseTexture.vScale = 5;\\r\\n\\r\\n    var y = 0;\\r\\n    for (var index = 0; index < 20; index++) {\\r\\n        var sphere = BABYLON.Mesh.CreateSphere(\\\"Sphere0\\\", 16, 1, scene);\\r\\n        sphere.material = materialAmiga;\\r\\n        sphere.position = new BABYLON.Vector3(Math.random() * 20 - 10, y, (Math.random() * 10 - 5) + 80);\\r\\n        sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 1, restitution: 0.8 }, scene);\\r\\n        y += 2;\\r\\n    }\\r\\n\\r\\n    // Link\\r\\n    var spheres = [];\\r\\n    for (index = 0; index < 10; index++) {\\r\\n        sphere = BABYLON.Mesh.CreateSphere(\\\"Sphere0\\\", 16, 0.8, scene);\\r\\n        spheres.push(sphere);\\r\\n        sphere.material = materialAmiga;\\r\\n        sphere.position = new BABYLON.Vector3(Math.random() * 20 - 10, 100, (Math.random() * 10 - 5 + 70));\\r\\n\\r\\n        sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 1 }, scene);\\r\\n    }\\r\\n\\r\\n    for (index = 0; index < 9; index++) {\\r\\n        spheres[index].setPhysicsLinkWith(spheres[index + 1], new BABYLON.Vector3(0, 0.5, 0), new BABYLON.Vector3(0, -0.5, 0));\\r\\n    }\\r\\n\\r\\n    //boxing area\\r\\n    const base = BABYLON.MeshBuilder.CreateBox('base', { width: 5, depth: 5, height: 0.1 });\\r\\n    base.position.set(0, 0, 90);\\r\\n    base.physicsImpostor = new BABYLON.PhysicsImpostor(base,\\r\\n        BABYLON.PhysicsImpostor.BoxImpostor,\\r\\n        { mass: 1000, friction: 0.5, restitution: 0 }, scene);\\r\\n\\r\\n    const boxingArray = [[], [], []]\\r\\n    const positions = [\\r\\n        new BABYLON.Vector3(0, 2.6, 90),\\r\\n        new BABYLON.Vector3(0, 2.3, 90),\\r\\n        new BABYLON.Vector3(0, 2.0, 90),\\r\\n        new BABYLON.Vector3(0, 1.7, 90),\\r\\n        new BABYLON.Vector3(0, 1.4, 90),\\r\\n    ];\\r\\n    let xPos = 0;\\r\\n    for (let i = -1; i < 2; ++i) {\\r\\n        positions.forEach((position, idx) => {\\r\\n            const boxingSphere = BABYLON.MeshBuilder.CreateSphere(`boxing_impostor`, { diameter: 0.2 }, scene);\\r\\n            boxingSphere.position.copyFrom(position);\\r\\n            boxingSphere.position.x = i;\\r\\n            boxingSphere.physicsImpostor = new BABYLON.PhysicsImpostor(boxingSphere, BABYLON.PhysicsImpostor.SphereImpostor, { mass: idx === 0 ? 0 : 1.1 + i }, scene);\\r\\n            boxingArray[i + 1].push(boxingSphere);\\r\\n\\r\\n            if (idx === 0) return;\\r\\n            const lockJoint = new BABYLON.PhysicsJoint(BABYLON.PhysicsJoint.LockJoint, {})\\r\\n            boxingArray[i + 1][idx - 1].physicsImpostor.addJoint(boxingSphere.physicsImpostor, lockJoint);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    // enable xr\\r\\n    const xr = await scene.createDefaultXRExperienceAsync({\\r\\n        floorMeshes: [ground]\\r\\n    });\\r\\n\\r\\n    // enable physics\\r\\n    const xrPhysics = xr.baseExperience.featuresManager.enableFeature(BABYLON.WebXRFeatureName.PHYSICS_CONTROLLERS, \\\"latest\\\", {\\r\\n        xrInput: xr.input,\\r\\n        physicsProperties: {\\r\\n            restitution: 0.5,\\r\\n            impostorSize: 0.1,\\r\\n            impostorType: BABYLON.PhysicsImpostor.BoxImpostor\\r\\n        },\\r\\n        enableHeadsetImpostor: true\\r\\n    });\\r\\n\\r\\n    let observers = {};\\r\\n    let meshesUnderPointer = {};\\r\\n    const tmpVec = new BABYLON.Vector3();\\r\\n    const tmpRay = new BABYLON.Ray();\\r\\n    tmpRay.origin = new BABYLON.Vector3();\\r\\n    tmpRay.direction = new BABYLON.Vector3();\\r\\n    let lastTimestamp = 0;\\r\\n    const oldPos = new BABYLON.Vector3();\\r\\n\\r\\n    const bullets = [];\\r\\n\\r\\n    // show how to use babylon's native pointer events to interact with the input source AND the mouse\\r\\n    scene.onPointerObservable.add((event) => {\\r\\n        if (event.type === BABYLON.PointerEventTypes.POINTERPICK) {\\r\\n            const inputSource = xr.pointerSelection.getXRControllerByPointerId(event.event.pointerId);\\r\\n            if (!inputSource || (inputSource && inputSource.motionController.handness === 'right')) {\\r\\n                const bullet = BABYLON.MeshBuilder.CreateSphere('bullet', { diameter: 0.2 });\\r\\n                // if (inputSource) {\\r\\n                //     inputSource.getWorldPointerRayToRef(tmpRay);\\r\\n                // }\\r\\n                const ray = /*inputSource ? tmpRay :*/event.pickInfo.ray;\\r\\n                ray.direction.scaleInPlace(0.2);\\r\\n                bullet.position.copyFrom(ray.origin);\\r\\n                bullet.position.addInPlace(ray.direction);\\r\\n                bullet.physicsImpostor = new BABYLON.PhysicsImpostor(bullet, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 3 });\\r\\n                bullet.physicsImpostor.setLinearVelocity(ray.direction.scale(400));\\r\\n            }\\r\\n        }\\r\\n    })\\r\\n\\r\\n    // XR-way of interacting with the controllers for the left hand:\\r\\n    xr.input.onControllerAddedObservable.add((controller) => {\\r\\n        controller.onMotionControllerInitObservable.add((motionController) => {\\r\\n            if (motionController.handness === 'left') {\\r\\n                motionController.getMainComponent().onButtonStateChangedObservable.add((component) => {\\r\\n                    if (component.changes.pressed) {\\r\\n                        if (component.pressed) {\\r\\n                            for (var x = 0; x < 7; x++) {\\r\\n                                for (var z = 0; z < 7; z++) {\\r\\n                                    const box1 = towerMeshes[x * 7 + z]\\r\\n                                    box1.position.x = (x - 4) * 6;\\r\\n                                    box1.position.y = 2 + z * 2;\\r\\n                                    box1.position.z = 100;\\r\\n                                    box1.rotationQuaternion = new BABYLON.Quaternion();\\r\\n                                    box1.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());\\r\\n                                    box1.physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());\\r\\n                                }\\r\\n                            }\\r\\n                            let bullt;\\r\\n                            while (bullt = bullets.pop()) {\\r\\n                                bullt.dispose();\\r\\n                            }\\r\\n                            Object.keys(observers).forEach(id => {\\r\\n                                xr.baseExperience.sessionManager.onXRFrameObservable.remove(observers[id]);\\r\\n                                observers[id] = null;\\r\\n                            });\\r\\n                        }\\r\\n                    }\\r\\n                });\\r\\n                // is squeeze available?\\r\\n                const squeeze = motionController.getComponentOfType('squeeze');\\r\\n                if (squeeze) {\\r\\n                    // check its state and handle state changes\\r\\n                    squeeze.onButtonStateChangedObservable.add(() => {\\r\\n                        // pressed was changed\\r\\n                        if (squeeze.changes.pressed) {\\r\\n                            // is it pressed?\\r\\n                            if (squeeze.pressed) {\\r\\n                                // animate position\\r\\n                                controller.getWorldPointerRayToRef(tmpRay, true);\\r\\n                                tmpRay.direction.scaleInPlace(1.5);\\r\\n                                const position = controller.grip ? controller.grip.position : controller.pointer.position;\\r\\n\\r\\n                                let mesh = scene.meshUnderPointer;\\r\\n                                if (xr.pointerSelection.getMeshUnderPointer) {\\r\\n                                    mesh = xr.pointerSelection.getMeshUnderPointer(controller.uniqueId);\\r\\n                                }\\r\\n                                if (mesh && mesh !== ground && mesh.physicsImpostor) {\\r\\n                                    const animatable = BABYLON.Animation.CreateAndStartAnimation('meshmove',\\r\\n                                        mesh, 'position', 30, 15, mesh.position.clone(),\\r\\n                                        position.add(tmpRay.direction),\\r\\n                                        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,\\r\\n                                        new BABYLON.BezierCurveEase(0.3, -0.75, 0.7, 1.6), () => {\\r\\n                                            if (!mesh) return;\\r\\n                                            meshesUnderPointer[controller.uniqueId] = mesh;\\r\\n                                            observers[controller.uniqueId] = xr.baseExperience.sessionManager.onXRFrameObservable.add(() => {\\r\\n                                                const delta = (xr.baseExperience.sessionManager.currentTimestamp - lastTimestamp);\\r\\n                                                lastTimestamp = xr.baseExperience.sessionManager.currentTimestamp;\\r\\n                                                controller.getWorldPointerRayToRef(tmpRay, true);\\r\\n                                                tmpRay.direction.scaleInPlace(1.5);\\r\\n                                                const position = controller.grip ? controller.grip.position : controller.pointer.position;\\r\\n                                                tmpVec.copyFrom(position);\\r\\n                                                tmpVec.addInPlace(tmpRay.direction);\\r\\n                                                tmpVec.subtractToRef(oldPos, tmpVec);\\r\\n                                                tmpVec.scaleInPlace(1000 / delta);\\r\\n                                                meshesUnderPointer[controller.uniqueId].position.copyFrom(position);\\r\\n                                                meshesUnderPointer[controller.uniqueId].position.addInPlace(tmpRay.direction);\\r\\n                                                oldPos.copyFrom(meshesUnderPointer[controller.uniqueId].position);\\r\\n                                                meshesUnderPointer[controller.uniqueId].physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());\\r\\n                                                meshesUnderPointer[controller.uniqueId].physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());\\r\\n                                            })\\r\\n                                        });\\r\\n                                }\\r\\n                            } else {\\r\\n                                // throw the object\\r\\n                                if (observers[controller.uniqueId] && meshesUnderPointer[controller.uniqueId]) {\\r\\n                                    xr.baseExperience.sessionManager.onXRFrameObservable.remove(observers[controller.uniqueId]);\\r\\n                                    observers[controller.uniqueId] = null;\\r\\n                                    meshesUnderPointer[controller.uniqueId].physicsImpostor.setLinearVelocity(tmpVec);\\r\\n                                }\\r\\n                            }\\r\\n                        }\\r\\n                    });\\r\\n                }\\r\\n            }\\r\\n        })\\r\\n    })\\r\\n\\r\\n\\r\\n    return scene;\\r\\n};\"}","name":"Babylon.js WebXR Physics playground","description":"playing around with webxr and physics using babylon.js","tags":"physics,xr,webxr,controllers"}
