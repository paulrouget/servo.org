{"id":"PPM311","version":63,"snippetIdentifier":"PPM311-63","jsonPayload":"{\"code\":\"/**\\r\\n * WebXR Golie training\\r\\n * \\r\\n * This demo was made to display a few of Babylon.js' WebXR features:\\r\\n * \\r\\n * - The WebXR motion controller repository was integrated - any supported controller is fully supported\\r\\n * - WebXR controllers can have physics impostors attached to them with one line of code.\\r\\n * - Teleportation is still working - you can teleport to a different location. Not that it will help you win the game ;-)\\r\\n * - You can play this game with the WebXR emulator. Thou I am pretty sure it will be VERY hard.\\r\\n * \\r\\n * If you have any questions contact RaananW at babylon's forum or on twitter \\r\\n */\\r\\n\\r\\n\\r\\nvar createScene = async function () {\\r\\n    // Create scene\\r\\n    var scene = new BABYLON.Scene(engine);\\r\\n\\r\\n    // Lights and camera\\r\\n    var light = new BABYLON.DirectionalLight(\\\"light\\\", new BABYLON.Vector3(0, -0.5, 1.0), scene);\\r\\n    light.position = new BABYLON.Vector3(0, 5, -6);\\r\\n    var camera = new BABYLON.ArcRotateCamera(\\\"camera\\\", -Math.PI / 2, Math.PI / 4, 3.8, new BABYLON.Vector3(0, 1, 0), scene);\\r\\n    camera.attachControl(canvas, true);\\r\\n    scene.activeCamera.beta += 0.8;\\r\\n\\r\\n    // Default Environment\\r\\n    var environment = scene.createDefaultEnvironment({ enableGroundShadow: true });\\r\\n    environment.setMainColor(BABYLON.Color3.FromHexString(\\\"#74b9ff\\\"))\\r\\n    environment.ground.parent.position.y = 0;\\r\\n    environment.ground.position.y = 0\\r\\n\\r\\n    // Shadows\\r\\n    var shadowGenerator = new BABYLON.ShadowGenerator(1024, light);\\r\\n    shadowGenerator.useBlurExponentialShadowMap = true;\\r\\n    shadowGenerator.blurKernel = 32;\\r\\n\\r\\n    // GUI\\r\\n    var plane = BABYLON.Mesh.CreatePlane(\\\"plane\\\", 1);\\r\\n    plane.position = new BABYLON.Vector3(0.4, 1.58, 0.4)\\r\\n    var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(plane);\\r\\n    var panel = new BABYLON.GUI.StackPanel();\\r\\n    advancedTexture.addControl(panel);\\r\\n    var header = new BABYLON.GUI.TextBlock();\\r\\n    header.text = \\\"Goalie Trainer\\\";\\r\\n    header.height = \\\"100px\\\";\\r\\n    header.color = \\\"white\\\";\\r\\n    header.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\\r\\n    header.fontSize = \\\"120\\\"\\r\\n    panel.addControl(header);\\r\\n    var easyButton = BABYLON.GUI.Button.CreateSimpleButton(\\\"onoff\\\", \\\"Easy\\\");\\r\\n    easyButton.onPointerClickObservable.add(() => {\\r\\n        gameConfig = easyConfig;\\r\\n        throwBalls = !throwBalls;\\r\\n        if (throwBalls) {\\r\\n            score = 0;\\r\\n            easyButton.background = \\\"red\\\";\\r\\n            header.text = \\\"Score: \\\" + score;\\r\\n            easyButton.textBlock.text = 'end';\\r\\n            hardButton.isVisible = false;\\r\\n        } else {\\r\\n            easyButton.background = \\\"green\\\";\\r\\n            easyButton.textBlock.text = 'Easy';\\r\\n            hardButton.textBlock.text = 'Hard';\\r\\n            header.text = \\\"Goalie Trainer\\\";\\r\\n            hardButton.isVisible = true;\\r\\n        }\\r\\n    });\\r\\n    easyButton.width = 0.5;\\r\\n    easyButton.height = \\\"80px\\\";\\r\\n    easyButton.color = \\\"white\\\";\\r\\n    easyButton.background = \\\"green\\\";\\r\\n    easyButton.fontSize = 60;\\r\\n    panel.addControl(easyButton);\\r\\n\\r\\n    var hardButton = BABYLON.GUI.Button.CreateSimpleButton(\\\"onoff\\\", \\\"Hard\\\");\\r\\n    hardButton.onPointerClickObservable.add(() => {\\r\\n        gameConfig = hardConfig;\\r\\n        throwBalls = !throwBalls;\\r\\n        if (throwBalls) {\\r\\n            score = 0;\\r\\n            easyButton.background = \\\"red\\\";\\r\\n            header.text = \\\"Score: \\\" + score;\\r\\n            easyButton.textBlock.text = 'Stop';\\r\\n            hardButton.isVisible = false;\\r\\n        }\\r\\n    });\\r\\n    hardButton.width = 0.5;\\r\\n    hardButton.height = \\\"80px\\\";\\r\\n    hardButton.color = \\\"white\\\";\\r\\n    hardButton.background = \\\"green\\\";\\r\\n    hardButton.fontSize = 60;\\r\\n    panel.addControl(hardButton);\\r\\n\\r\\n    // game configuration\\r\\n    const easyConfig = {\\r\\n        ballSize: 0.5,\\r\\n        forceFactor: 1,\\r\\n        heightFactor: 1\\r\\n    }\\r\\n\\r\\n    const hardConfig = {\\r\\n        ballSize: 0.3,\\r\\n        forceFactor: 1.35,\\r\\n        heightFactor: 0.925\\r\\n    }\\r\\n\\r\\n    let gameConfig = {\\r\\n        ...easyConfig\\r\\n    }\\r\\n\\r\\n\\r\\n    // physics\\r\\n    scene.enablePhysics(undefined, new BABYLON.AmmoJSPlugin());\\r\\n\\r\\n    // clone the ground to create parentless impostor\\r\\n    const groundNoParent = environment.ground.clone();\\r\\n    groundNoParent.isVisible = false;\\r\\n    groundNoParent.parent = undefined;\\r\\n    groundNoParent.setAbsolutePosition(environment.ground.getAbsolutePosition());\\r\\n    groundNoParent.material = undefined;\\r\\n    groundNoParent.physicsImpostor = new BABYLON.PhysicsImpostor(groundNoParent, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.5 });\\r\\n\\r\\n    // build the goal\\r\\n    const goalHeight = 2;\\r\\n    const goalWidth = 3;\\r\\n    const goalDepth = 0.8;\\r\\n    const rightPole = BABYLON.BoxBuilder.CreateBox(\\\"goal\\\", { width: 0.1, height: goalHeight, depth: 0.1 });\\r\\n    const leftPole = rightPole.clone();\\r\\n    rightPole.position.set(goalWidth / 2, goalHeight / 2, -5);\\r\\n    leftPole.position.set(-goalWidth / 2, goalHeight / 2, -5);\\r\\n    const upperPole = BABYLON.BoxBuilder.CreateBox(\\\"goal\\\", { width: goalWidth, height: 0.1, depth: 0.1 });\\r\\n    upperPole.position.set(0, goalHeight, -5);\\r\\n\\r\\n    let goal = BABYLON.BoxBuilder.CreateBox(\\\"goal\\\", { width: 3, height: 2, depth: 0.098 });\\r\\n    goal.position.y = 1;\\r\\n    goal.position.z = -5;\\r\\n    const material = new BABYLON.GridMaterial(\\\"groundMaterial\\\", scene);\\r\\n    material.gridRatio = 0.1;\\r\\n    material.majorUnitFrequency = 1;\\r\\n    material.opacity = 0.9;\\r\\n    goal.material = material;\\r\\n\\r\\n    shadowGenerator.addShadowCaster(rightPole);\\r\\n    shadowGenerator.addShadowCaster(leftPole);\\r\\n    shadowGenerator.addShadowCaster(upperPole);\\r\\n    shadowGenerator.addShadowCaster(goal);\\r\\n\\r\\n    rightPole.physicsImpostor = new BABYLON.PhysicsImpostor(rightPole, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0 })\\r\\n    leftPole.physicsImpostor = new BABYLON.PhysicsImpostor(leftPole, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0 })\\r\\n    upperPole.physicsImpostor = new BABYLON.PhysicsImpostor(upperPole, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0 })\\r\\n    goal.physicsImpostor = new BABYLON.PhysicsImpostor(goal, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0 })\\r\\n\\r\\n\\r\\n    let counter = 0;\\r\\n    const spheres = [];\\r\\n\\r\\n    // Enable XR\\r\\n    var xr = await scene.createDefaultXRExperienceAsync({ floorMeshes: [environment.ground] });\\r\\n\\r\\n    // Add controllers to shadow.\\r\\n    xr.input.onControllerAddedObservable.add((controller) => {\\r\\n        // future safe\\r\\n        if (controller.onMeshLoadedObservable) {\\r\\n            controller.onMeshLoadedObservable.addOnce((rootMesh) => {\\r\\n                shadowGenerator.addShadowCaster(rootMesh, true);\\r\\n            });\\r\\n        } else {\\r\\n            controller.onMotionControllerProfileLoaded.addOnce((motionController) => {\\r\\n                motionController.onModelLoadedObservable.addOnce(() => {\\r\\n                    shadowGenerator.addShadowCaster(motionController.rootMesh, true);\\r\\n                });\\r\\n            });\\r\\n        }\\r\\n    });\\r\\n\\r\\n    // get the features manager\\r\\n    const fm = xr.baseExperience.featuresManager;\\r\\n\\r\\n    // enable physics on the motion controllers\\r\\n    const xrPhysics = fm.enableFeature(BABYLON.WebXRFeatureName.PHYSICS_CONTROLLERS, \\\"latest\\\", {\\r\\n        xrInput: xr.input,\\r\\n        physicsProperties: {\\r\\n            restitution: 0.5,\\r\\n            impostorSize: 0.15\\r\\n        }\\r\\n    });\\r\\n\\r\\n    let throwBalls = false;\\r\\n    let score = 0;\\r\\n\\r\\n    // XR loop - throwing balls only when inside the session\\r\\n    xr.baseExperience.sessionManager.onXRFrameObservable.add(() => {\\r\\n        if (!throwBalls) return;\\r\\n        // throw a ball every 2 seconds\\r\\n        if (counter++ === 120 && spheres.length < 10) {\\r\\n            counter = 0;\\r\\n            const sphere = BABYLON.SphereBuilder.CreateSphere(\\\"sphere\\\", { diameter: gameConfig.ballSize }, scene);\\r\\n            shadowGenerator.addShadowCaster(sphere);\\r\\n            spheres.push(sphere);\\r\\n            sphere.position.z = 5;\\r\\n            sphere.position.y = 0.2;\\r\\n            sphere.position.x += Math.random() * 2;\\r\\n            sphere.position.x -= Math.random() * 2;\\r\\n            sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 0.7, restitution: 0.5 });\\r\\n            // shoot the ball up\\r\\n            sphere.physicsImpostor.applyImpulse(new BABYLON.Vector3(0, 6.5 * gameConfig.heightFactor, 0), BABYLON.Vector3.Zero());\\r\\n            let sphereTouchedGround = 0;\\r\\n            // goal? bad for you...\\r\\n            sphere.physicsImpostor.registerOnPhysicsCollide(goal.physicsImpostor, (collider, collidedAgainst) => {\\r\\n                if (sphere.hitGoal) return;\\r\\n                score--;\\r\\n                header.text = \\\"Score: \\\" + score;\\r\\n                sphere.hitGoal = true;\\r\\n            });\\r\\n\\r\\n            // a ball that touched the ground more than 4 times is considered a win\\r\\n            sphere.physicsImpostor.registerOnPhysicsCollide(groundNoParent.physicsImpostor, (collider, collidedAgainst) => {\\r\\n                sphereTouchedGround++;\\r\\n                if (sphereTouchedGround > 4 || sphere.hitGoal) {\\r\\n                    score += sphere.hitGoal ? 0 : 1;\\r\\n                    header.text = \\\"Score: \\\" + score;\\r\\n                    sphere.dispose();\\r\\n                }\\r\\n            });\\r\\n            // shoot the ball forward after a second\\r\\n            setTimeout(() => {\\r\\n                sphere.physicsImpostor.applyImpulse(new BABYLON.Vector3(0, 0, -(8 * gameConfig.forceFactor) - Math.random() + Math.random() - Math.random()), BABYLON.Vector3.Zero());\\r\\n            }, 1000);\\r\\n        }\\r\\n\\r\\n        // check the spheres array and filter it\\r\\n        const alive = spheres.filter((s) => s.position.y > 0 && !s.isDisposed());\\r\\n\\r\\n        spheres.forEach((s) => {\\r\\n            if (s.position.y < 0) {\\r\\n                score += s.hitGoal ? 0 : 1;\\r\\n                header.text = \\\"Score: \\\" + score;\\r\\n                s.dispose();\\r\\n            }\\r\\n        });\\r\\n\\r\\n        spheres.splice(0, spheres.length, ...alive);\\r\\n    });\\r\\n\\r\\n    return scene;\\r\\n};\"}","name":"XR Goal Keeper Training","description":"Goal Keeper training based on WebXR.\n\n(RaananW)","tags":"webxr, physics"}