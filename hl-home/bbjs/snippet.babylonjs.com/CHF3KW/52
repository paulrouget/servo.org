{"id":"CHF3KW","version":52,"snippetIdentifier":"CHF3KW-52","jsonPayload":"{\"code\":\"/**\\r\\n * Simple tennis game with Babylon.js and WebXR.\\r\\n * \\r\\n * Physics using Ammo.js\\r\\n * \\r\\n * Use the left hand to controll the ball, and the right hand to play :-)\\r\\n * \\r\\n * Created by Raanan Weber, @RaananW\\r\\n */\\r\\n\\r\\nvar createScene = async function () {\\r\\n    // Create scene\\r\\n    var scene = new BABYLON.Scene(engine);\\r\\n\\r\\n    // Lights and camera\\r\\n    var light = new BABYLON.DirectionalLight(\\\"light\\\", new BABYLON.Vector3(0, -0.5, 1.0), scene);\\r\\n    light.position = new BABYLON.Vector3(0, 5, -6);\\r\\n    var camera = new BABYLON.ArcRotateCamera(\\\"camera\\\", -Math.PI / 2, Math.PI / 4 + 0.8, 6, new BABYLON.Vector3(0, 1, 0), scene);\\r\\n    camera.attachControl(canvas, true);\\r\\n\\r\\n    // Default Environment\\r\\n    var environment = scene.createDefaultEnvironment({ enableGroundShadow: true, });\\r\\n    environment.setMainColor(BABYLON.Color3.FromHexString(\\\"#74b9ff\\\"));\\r\\n\\r\\n    // Shadows\\r\\n    var shadowGenerator = new BABYLON.ShadowGenerator(1024, light);\\r\\n    shadowGenerator.useBlurExponentialShadowMap = true;\\r\\n    shadowGenerator.blurKernel = 32;\\r\\n\\r\\n    // physics\\r\\n    scene.enablePhysics(undefined, new BABYLON.AmmoJSPlugin());\\r\\n\\r\\n    // clone the ground to create parentless impostor\\r\\n    const groundNoParent = BABYLON.MeshBuilder.CreateBox('physicsground', {\\r\\n        width: 10,\\r\\n        depth: 20,\\r\\n        height: 0.2\\r\\n    });\\r\\n    groundNoParent.position.y = -0.095\\r\\n    //groundNoParent.isVisible = false;\\r\\n    groundNoParent.parent = undefined;\\r\\n    groundNoParent.setAbsolutePosition(environment.ground.getAbsolutePosition());\\r\\n    groundNoParent.physicsImpostor = new BABYLON.PhysicsImpostor(groundNoParent, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.85 });\\r\\n\\r\\n    groundNoParent.receiveShadows = true;\\r\\n    // Enable XR\\r\\n    // var xr = await scene.createDefaultXRExperienceAsync({\\r\\n    //     floorMeshes: [environment.ground], inputOptions: {\\r\\n    //         doNotLoadControllerMeshes: false\\r\\n    //     }\\r\\n    // });\\r\\n\\r\\n    const xr = await scene.createDefaultXRExperienceAsync({\\r\\n        floorMeshes: [environment.ground],\\r\\n        uiOptions: {\\r\\n            sessionMode: \\\"immersive-ar\\\",\\r\\n            referenceSpaceType: \\\"local-floor\\\"},\\r\\n        inputOptions: {\\r\\n            doNotLoadControllerMeshes: false}\\r\\n    });\\r\\n\\r\\n    xr.pointerSelection.detach();\\r\\n\\r\\n    const fm = xr.baseExperience.featuresManager;\\r\\n    const xrBackgroundRemover = fm.enableFeature(BABYLON.WebXRBackgroundRemover.Name);\\r\\n\\r\\n    // create the net\\r\\n    const netHeight = 0.6;\\r\\n    const net = BABYLON.MeshBuilder.CreateBox('net', { width: 5, height: netHeight, depth: 0.1 });\\r\\n    net.position.y = netHeight / 2;\\r\\n    const material = new BABYLON.GridMaterial(\\\"groundMaterial\\\", scene);\\r\\n    material.gridRatio = 0.02;\\r\\n    material.majorUnitFrequency = 1;\\r\\n    material.opacity = 0.9;\\r\\n    material.backFaceCulling = false;\\r\\n    net.material = material;\\r\\n    net.physicsImpostor = new BABYLON.PhysicsImpostor(net, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.2 });\\r\\n\\r\\n    // bounding walls\\r\\n    const wall = BABYLON.MeshBuilder.CreateBox('net', { width: 8, height: 3, depth: 0.3 });\\r\\n    wall.position.z = 8;\\r\\n    wall.position.y = 1.5;\\r\\n    const wallRight = wall.clone();\\r\\n    wallRight.rotate(BABYLON.Axis.Y, Math.PI / 2);\\r\\n    wallRight.position.set(4, 1.5, 4);\\r\\n    const wallLeft = wallRight.clone();\\r\\n    wallLeft.rotate(BABYLON.Axis.Y, Math.PI);\\r\\n    wallLeft.position.x = -4;\\r\\n\\r\\n    [wall, wallLeft, wallRight].forEach(mesh => {\\r\\n        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.9 });\\r\\n    });\\r\\n\\r\\n    // create the ball\\r\\n    let ball = BABYLON.MeshBuilder.CreateSphere(\\\"ball\\\", {\\r\\n        diameter: 0.2,\\r\\n        segments: 8\\r\\n    });\\r\\n    ball.position.y = 2;\\r\\n    ball.position.z = -1;\\r\\n    ball.isVisible = false;\\r\\n    shadowGenerator.addShadowCaster(ball);\\r\\n    ball.physicsImpostor = new BABYLON.PhysicsImpostor(ball, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 1, restitution: 0.9 });\\r\\n    let observer;\\r\\n    // create the racket\\r\\n    const racket = BABYLON.MeshBuilder.CreateDisc('racket', {\\r\\n        radius: 0.2,\\r\\n    });\\r\\n    racket.rotate(BABYLON.Axis.X, Math.PI / 2);\\r\\n    racket.rotate(BABYLON.Axis.Y, Math.PI / 2);\\r\\n    racket.bakeCurrentTransformIntoVertices();\\r\\n    racket.material = material;\\r\\n    racket.isVisible = false;\\r\\n    racket.physicsImpostor = new BABYLON.PhysicsImpostor(racket, BABYLON.PhysicsImpostor.MeshImpostor, { mass: 0, restitution: 0.9 });\\r\\n    shadowGenerator.addShadowCaster(racket);\\r\\n    const tmpVec = new BABYLON.Vector3();\\r\\n    const tmpRay = new BABYLON.Ray();\\r\\n    tmpRay.origin = new BABYLON.Vector3();\\r\\n    tmpRay.direction = new BABYLON.Vector3();\\r\\n    let lastTimestamp = 0;\\r\\n    const oldPos = new BABYLON.Vector3();\\r\\n\\r\\n    xr.input.onControllerAddedObservable.add((controller) => {\\r\\n        ball.isVisible = true;\\r\\n        racket.isVisible = true;\\r\\n\\r\\n        if (controller.inputSource.handedness === 'right') {\\r\\n            const handle = BABYLON.MeshBuilder.CreateCylinder('handle', {\\r\\n                height: 0.4, diameter: 0.02, tessellation: 8\\r\\n            });\\r\\n            handle.rotate(BABYLON.Axis.X, Math.PI / 2);\\r\\n            handle.position.z += 0.2;\\r\\n            handle.parent = controller.grip || controller.pointer;\\r\\n            shadowGenerator.addShadowCaster(handle);\\r\\n            const frameObserver = xr.baseExperience.sessionManager.onXRFrameObservable.add(() => {\\r\\n                controller.getWorldPointerRayToRef(tmpRay, true);\\r\\n                racket.position.copyFrom(handle.absolutePosition);\\r\\n                racket.position.addInPlace(tmpRay.direction.scaleInPlace(0.2));\\r\\n                racket.rotationQuaternion.copyFrom(handle.parent.rotationQuaternion);\\r\\n            });\\r\\n\\r\\n            xr.input.onControllerRemovedObservable.add(() => {\\r\\n                racket.isVisible = false;\\r\\n                xr.baseExperience.sessionManager.onXRFrameObservable.remove(frameObserver);\\r\\n            });\\r\\n        }\\r\\n\\r\\n        if (controller.inputSource.handedness === 'left') {\\r\\n            const handle = BABYLON.MeshBuilder.CreateCylinder('handle', {\\r\\n                height: 0.4, diameter: 0.02, tessellation: 8\\r\\n            });\\r\\n            handle.rotate(BABYLON.Axis.X, Math.PI / 2);\\r\\n            handle.position.z += 0.2;\\r\\n            handle.parent = controller.grip || controller.pointer;\\r\\n        }\\r\\n\\r\\n        controller.onMeshLoadedObservable.addOnce((rootMesh) => {\\r\\n            shadowGenerator.addShadowCaster(rootMesh, true);\\r\\n        });\\r\\n\\r\\n        controller.onMotionControllerInitObservable.add(() => {\\r\\n            if (controller.inputSource.handedness === 'left') {\\r\\n                const component = controller.motionController.getComponent(\\\"xr-standard-thumbstick\\\");\\r\\n                component.onButtonStateChangedObservable.add(() => {\\r\\n                    if (component.changes.pressed) {\\r\\n                        if (component.pressed) {\\r\\n                            observer = xr.baseExperience.sessionManager.onXRFrameObservable.add(() => {\\r\\n                                const delta = (xr.baseExperience.sessionManager.currentTimestamp - lastTimestamp);\\r\\n                                lastTimestamp = xr.baseExperience.sessionManager.currentTimestamp;\\r\\n                                controller.getWorldPointerRayToRef(tmpRay, true);\\r\\n                                tmpRay.direction.scaleInPlace(1.2);\\r\\n                                const position = controller.grip ? controller.grip.position : controller.pointer.position;\\r\\n                                tmpVec.copyFrom(position);\\r\\n                                tmpVec.addInPlace(tmpRay.direction);\\r\\n                                tmpVec.subtractToRef(oldPos, tmpVec);\\r\\n                                tmpVec.scaleInPlace(1000 / delta);\\r\\n                                ball.position.copyFrom(position);\\r\\n                                ball.position.addInPlace(tmpRay.direction);\\r\\n                                oldPos.copyFrom(ball.position);\\r\\n                                ball.physicsImpostor.setLinearVelocity(BABYLON.Vector3.Zero());\\r\\n                                ball.physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());\\r\\n                            })\\r\\n                        } else {\\r\\n                            // throw a ball, if exists\\r\\n                            if (observer) {\\r\\n                                xr.baseExperience.sessionManager.onXRFrameObservable.remove(observer);\\r\\n                                observer = null;\\r\\n                                ball.physicsImpostor.setLinearVelocity(tmpVec);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                })\\r\\n            }\\r\\n        });\\r\\n    });\\r\\n\\r\\n    return scene;\\r\\n};\"}","name":"Babylon.js WebXR Tennis game","description":"This demo shows how to create a very simple tennis game using a physics engine, webxr and babylon.js","tags":"webxr,physics,tennis,sports,controllers"}